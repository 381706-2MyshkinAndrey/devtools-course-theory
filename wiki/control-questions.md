-----------

1. [Текстовые форматы](#text)
1. [Обработка текста](#text-processing)
1. [Системы контроля версий](#vcs)
1. [Автоматизация](#automation)
1. [Построение проектов](#build)
1. [Тестирование](#test)
1. [Непрерывная интеграция](#ci)
1. [Анализ бинарных модулей](#binary)
1. [Отладка](#debug)
1. [Оптимизация и профилировка](#profiling)
1. [Дополнительные вопросы](#extra)

-----------

<a name="text"/>
### 1. Текстовые форматы

  1. Преимущества простого текста
  1. Преимущества бинарного формата
  1. Примеры ситуаций, когда удобно использовать TXT, XML, YAML, JSON
  1. Синтаксис Markdown (заголовки, стили, списки, ссылки)
  1. Примеры использования Markdown, в том числе нестандартные. В чем конкретно
     преимущество использования Markdown.

<a name="text-processing"/>
### 2. Обработка текста

  1. Как будет выглядет команда в Vim для:
     - Создания 10 копий текущей строки
     - Перевода всей строки в верхний регистр (капитализация)
  1. Предложите регулярное выражение для поиска:
     - Имен всех классов в вашем С++ проекте
     - Поиска всех дат в формате 2013-09-18 или 14-01-01
  1. Предложите командную строку для:
     - Поиска всех вызовов виртуального метода в директории с исходниками
     - Печати всех заголовков первого и второго уровня в файле Markdown (#-нотация)

<a name="vcs"/>
### 3. Системы контроля версий

  1. Определение СКВ
  1. Основные функции/возможности современных СКВ
  1. Базовые принципы корректной работы с СКВ
  1. Рабочий процесс (модель ветвления), используемый в компании GitHub

<a name="automation"/>
### 4. Автоматизация

  1. Выгоды автоматизации
  2. Типичные классы задач на автоматизацию
  3. Философия UNIX
  4. Преимущества UNIX при автоматизации

<a name="build"/>
### 5. Построение проектов

  1. Определение ИСР, их основные модули
  2. Основные функции/возможности 
     современных ИСР
  3. Определение метапрограммирования и его примеры
  4. Иcтория развития билд-систем
  5. Плюсы и минусы Makefile
  6. Плюсы и минусы CMake

<a name="test"/>
### 6. Тестирование

  1. Классификация тестов по назначению.
  2. Современная стратегия тестирования (основные 5 утверждений).
  3. Основные возможности фреймворков модульного тестирования.
  4. Критерии хорошего теста.
  5. Возможности Google Test.
  6. Порядок использования Google Test.

<a name="ci"/>
### 7. Непрерывная интеграция

  1. Определение практики непрерывной интеграции
  2. Преимущества, которые дает использование практики НИ
  3. Требования к проекту
  4. Задачи выделенного сервера
  5. Преимущества и недостатки Travis
  6. Преимущества и недостатки BuildBot

<a name="binary"/>
### 8. Анализ бинарных модулей

1. Определение: Исполняемый модуль
2. Определение: API
3. Зачем нужно разделение на сегменты и секции в исполняемых модулях?
4. Что такое статическое и динамическое связывание, в чём их отличия?
5. Что такое бинарная совместимость и совместимость на уровне исходного кода?

<a name="debug"/>
### 9. Отладка

  1. Что такое отладка и отладчик?
  2. Назовите 3 метода отладки и опишите их.
  3. Опишите алгоритм отладки "Волчья ограда" (wolf fence).
  4. Расшифруйте и объясните следующие термины: breakpoint, watchpoint,
     checkpoint, catchpoint и call stack.
  5. Перечислите 3 распространенных приема против отладки
  6. Объясните назначение отладочной информации и как нужно скомпилировать
     программу, чтобы она была
  7. Напишите 5 команд отладчика GDB (запуск, поставить точку останова с
     условием, продолжить, распечатать локальные переменные, завершить работу
     отладчика)

<a name="profiling"/>
### 10. Оптимизация и профилировка

  1. В каком случае оптимизация программ оправдана?
  2. При выполнении каких условий имеет смысл приступать к оптимизации?
  3. Что такое бенчмарк?
  4. Назовите основные требования к бенчмарку.
  5. Какие задачи решает профилировщик и в какой степени?
  6. Какая оптимизация как правило дает основной выигрыш в смысле времени работы
     программы?
  7. Какие критерии оптимизации программ Вам известны?

<a name="extra"/>
### Дополнительные вопросы

  1. Написать регулярные выражения для
     1. Времени в американском формате (9:00 AM, но не 19:77 AM)
     1. Номеров мобильных телефонов в России
     1. Веб-адресов
  1. Сравнительный анализ интерфейсов командной строки и графического
  1. Какие будут негативные последствия при:
     1. Нарушении базовых принципов работы с VCS
     1. Недостаточном использовании автоматизации в проекте
     1. Тестировании без использования соответствующих фреймворков
     1. Отсутствии практики непрерывной интеграции
  1. Какие полезные следствия имеет то, что Travis (CMake, GTest) является
     популярным инструментом
  1. Почему важно поддерживать бинарную (на уровне исходников) совместимость
     API, в каких случаях допустимо ее нарушать? (см. <http://semver.org/lang/ru/>)
